// src/notebook/array/ArrayUtil.java
/**
 * The i'th smallest, where i is 0 based
 */
public static int ith(int[] arr, int i) {
    int l = 0, h = arr.length - 1;
    while (l <= h) {
        int p = partition(arr, l, h);
        if (p == i)
            return arr[p];
        else if (p < i)
            l = p + 1;
        else
            h = p - 1;
    }
    return -1;
}

// src/notebook/array/ArrayUtil.java
public static int kthLargest(int[] arr, int k) {
    int l = 0, h = arr.length - 1;
    while (l <= h) {
        int p = partition(arr, l, h);
        int rank = arr.length - p;
        if (rank == k)
            return arr[p];
        else if (rank > k)
            l = p + 1;
        else
            h = p - 1;
    }
    return -1;
}

// src/notebook/array/ArrayUtil.java
public static int partition(int[] arr, int l, int h) {
    for (int i = l; i < h; i++)
        if (arr[i] < arr[h])
            swap(arr, i, l++);
    swap(arr, l, h);
    return l;
}

// src/notebook/array/LargestRectangleInHistogram.java
public static int largestRectangleArea(int[] h) {
    int n = h.length, stack[] = new int[n], size = 0, max = 0;
    if (n == 0)
        return 0;
    for (int i = 0; i <= n; i++) {
        while (size > 0 && (i == n || h[stack[size - 1]] >= h[i]))
            max = Math.max(max, h[stack[--size]] * (i - (size == 0 ? 0 : 1 + stack[size - 1])));
        stack[size++] = i;
    }
    return max;
}

// src/notebook/array/LongestIncreasingSubsequence.java
/**
 * O(n*log(n)) DP solution
 */
public static int[] getLIS_log(int... arr) {
    if (arr.length == 0)
        return new int[0];
    int len = 0, dp[] = new int[arr.length];
    int p[] = new int[arr.length];
    for (int i = 0; i < arr.length; i++) {
        int l = 0, h = len - 1;
        while (l <= h) {
            int mid = (l + h) >>> 1;
            if (arr[dp[mid]] == arr[i]) {
                l = mid;
                break;
            } else if (arr[dp[mid]] < arr[i]) {
                l = mid + 1;
            } else {
                h = mid - 1;
            }
        }
        dp[l] = i;
        if (len == l)
            len++;
        if (l > 0)
            p[i] = dp[l - 1];
    }
    int lis[] = new int[len], arrIndex = dp[len - 1];
    for (int i = len - 1; i >= 0; i--) {
        lis[i] = arr[arrIndex]; // or we can return indexes
        arrIndex = p[arrIndex];
    }
    return lis;
}

// src/notebook/array/LongestIncreasingSubsequence.java
/**
 * classic DP solution O(n^2)
 */
public static int[] getLIS_quadratic(int... arr) {
    if (arr.length == 0)
        return new int[0];
    int l[] = new int[arr.length]; // l[i] := length of LIS ending at i
    int p[] = new int[arr.length]; // p[i] := predecessor of i
    int maxIndex = 0; // index of max LIS
    for (int i = 0; i < arr.length; i++) {
        l[i] = 1;
        p[i] = -1;
        for (int j = 0; j < i; j++) {
            if (arr[j] < arr[i] && l[i] < l[j] + 1) {
                l[i] = l[j] + 1;
                p[i] = j;
            }
        }
        if (l[i] > l[maxIndex])
            maxIndex = i;
    }
    int lis[] = new int[l[maxIndex]], arrIndex = maxIndex;
    for (int i = lis.length - 1; i >= 0; i--) {
        lis[i] = arr[arrIndex]; // or we can return indexes
        arrIndex = p[arrIndex];
    }
    return lis;
}

// src/notebook/array/LongestIncreasingSubsequence.java
/**
 * @return length of LIS
 */
public static int lenLIS_log(int... arr) {
    // DP[i] := smallest tail of LIS of length (i + 1)
    int[] dp = new int[arr.length];
    int len = 0; // effective length of DP
    for (int n : arr) {
        int i = Arrays.binarySearch(dp, 0, len, n);
        if (i < 0)
            i = ~i;
        dp[i] = n;
        if (i == len)
            len++;
    }
    return len;
}

// src/notebook/array/LongestIncreasingSubsequence.java
/**
 * @return length of LIS
 */
public static int lenLIS_quadratic(int... arr) {
    if (arr.length == 0)
        return 0;
    // DP[i] := length of LIS ending at i
    int dp[] = new int[arr.length];
    int max = 0;
    for (int i = 0; i < arr.length; i++) {
        dp[i] = 1;
        for (int j = 0; j < i; j++)
            if (arr[j] < arr[i])
                dp[i] = Math.max(dp[i], 1 + dp[j]);
        max = Math.max(max, dp[i]);
    }
    return max;
}

// src/notebook/bit/GrayCode.java
public static int toBinary(int n) {
    for (int m = n >> 1; m != 0; m >>= 1)
        n = n ^ m;
    return n;
}

// src/notebook/bit/GrayCode.java
public static int toGrayCode(int n) {
    return n ^ (n >> 1);
}

// src/notebook/bit/MaximumXOR.java
/**
 * @return maximum XOR of two numbers
 */
public int findMaximumXOR(int[] nums) {
    int max = 0, mask = 0;
    for (int i = 30; i >= 0; i--) {
        int m = 1 << i;
        mask |= m;
        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num & mask);
        }
        // test if i'th bit of max can be set, given LHS bits
        int tmp = max | m;
        for (int prefix : set) {
            // there exist prefix x and y such that (x ^ y) = (max | m)
            if (set.contains(tmp ^ prefix)) {
                max = tmp;
                break;
            }
        }
    }
    return max;
}

// src/notebook/combination/Combinations.java
/**
 * @return all k-combinations of [0...n-1]
 */
public static List<List<Integer>> combinations(int n, int k) {
    Queue<List<Integer>> q = new LinkedList<>(Arrays.asList(new ArrayList<>()));
    while (q.peek().size() < k) {
        List<Integer> l = q.poll();
        int last = l.isEmpty() ? -1 : l.get(l.size() - 1);
        for (int i = last + 1; i <= n - k + l.size(); i++) {
            List<Integer> copy = new ArrayList<>(l);
            copy.add(i);
            q.offer(copy);
        }
    }
    return new ArrayList<>(q);
}

// src/notebook/combination/Combinations.java
public static long choose(int n, int k) {
    long ans = 1;
    for (int i = 0; i < k; i++) {
        ans *= (n - i);
        ans /= (1 + i);
    }
    return ans;
}

// src/notebook/gcd/ChineseRemainderTheorem.java
/**
 * @return n (MOD r*s) such that n == a (MOD r) and n == b (MOD s)
 */
public static long getN(long r, long s, long a, long b) {
    ExtendedEuclid ans = ExtendedEuclid.gcd(r, s);

    if (Math.abs(ans.gcd) != 1)
        throw new IllegalArgumentException("gcd(r, s) must be 1");

    long n = b * r * ans.x + a * s * ans.y, rs = r * s;

    return (n % rs + rs) % rs; // least positive n (MOD r*s)
}

// src/notebook/gcd/ExtendedEuclid.java
public class ExtendedEuclid {
    /**
     * @return GCD(a, b) = ax + by
     */
    public static ExtendedEuclid gcd(long a, long b) {
        ExtendedEuclid ans = new ExtendedEuclid();
        if (b == 0) {
            ans.gcd = a;
            ans.a = a;
            ans.b = b;
            ans.x = 1;
            ans.y = 0;
            return ans;
        }
        ans = gcd(b, a % b);
        long x = ans.x, y = ans.y, q = a / b;

        ans.gcd = ans.gcd;
        ans.a = a;
        ans.b = b;
        ans.x = y;
        ans.y = x - y * q;

        return ans;
    }

    public long gcd, a, x, b, y;

    @Override
    public String toString() {
        return String.format("%d = %d * %d + %d * %d", gcd, a, x, b, y);
    }

}

// src/notebook/gcd/GCD.java
public static long gcd_rec(long a, long b) {
    // add Math.abs when necessary
    return b == 0 ? a : gcd_rec(b, a % b);
}

// src/notebook/gcd/GCD.java
public static long gcd_itr(long a, long b) {
    // add Math.abs when necessary
    long r;
    while (b != 0) {
        r = a % b;
        a = b;
        b = r;
    }
    return a;
}

// src/notebook/geometry/Line2DUtil.java
public static double distanceLineToOrigin(int[][] l) {
    int x1 = l[0][0], y1 = l[0][1], x2 = l[1][0], y2 = l[1][1];
    double top = Math.abs(x2 * y1 - y2 * x1);
    double bot = Math.hypot(y2 - y1, x2 - x1);
    return top / bot;
}

// src/notebook/geometry/Line2DUtil.java
public static double distanceLineToPoint(int[][] l, int[] p) {
    int x0 = p[0], y0 = p[1], x1 = l[0][0], y1 = l[0][1], x2 = l[1][0], y2 = l[1][1];
    double top = Math.abs((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1);
    double bot = Math.hypot(y2 - y1, x2 - x1);
    return top / bot;
}

// src/notebook/geometry/Point2DUtil.java
/**
 * @return positive if counter-clockwise, negative if clockwise, 0 otherwise
 */
public static int ccw(Point a, Point b, Point c) {
    return a.x * b.y - a.y * b.x + b.x * c.y - b.y * c.x + c.x * a.y - c.y * a.x;
}

// src/notebook/graph/Dijkstra.java
public class Dijkstra<V> {

    private static final long INFINITY = Long.MAX_VALUE;

    private final Map<V, Map<V, Long>> outMap = new HashMap<>();

    private final Map<V, Long> distMap = new HashMap<>();

    public void addEdge(V from, V to, long cost) {
        get(from).put(to, cost);
    }

    public long runDijkstra(V s, V t) {
        distMap.clear();
        distMap.put(s, 0L);

        Queue<V> pq = new PriorityQueue<>((p, q) -> Long.compare(dist(p), dist(q)));
        pq.offer(s);

        while (!pq.isEmpty()) {
            V cur = pq.poll();
            long curDist = dist(cur);
            if (cur.equals(t))
                return curDist;

            for (Map.Entry<V, Long> entry : outMap.get(cur).entrySet()) {
                V neighbor = entry.getKey();
                long neighborCost = entry.getValue();
                long neighborDist = dist(neighbor);
                long altDist = curDist + neighborCost;
                if (altDist < neighborDist) {
                    distMap.put(neighbor, altDist);
                    pq.offer(neighbor);
                }
            }
        }
        return INFINITY;
    }

    public long dist(V v) {
        return distMap.getOrDefault(v, INFINITY);
    }

    private Map<V, Long> get(V from) {
        Map<V, Long> map = outMap.get(from);
        if (map == null)
            outMap.put(from, map = new HashMap<>());
        return map;
    }

}

// src/notebook/graph/MaxFlow.java
public class MaxFlow<V> {

    private final Map<V, Map<V, Long>> capMap = new HashMap<>();

    public void addEdge(V from, V to, long cap) {
        get(from).put(to, cap);
    }

    private long bfs(V s, V t) {
        Queue<V> q = new LinkedList<>();
        q.offer(s);

        Map<V, V> parent = new HashMap<>();
        Set<V> visited = new HashSet<>();

        while (!q.isEmpty()) {
            V v = q.poll();
            visited.add(v);
            if (v.equals(t))
                break;
            for (Map.Entry<V, Long> entry : get(v).entrySet()) {
                V w = entry.getKey();
                if (entry.getValue() > 0 && !visited.contains(w)) {
                    q.offer(w);
                    parent.put(w, v);
                }
            }
        }
        // if there exists s-t path
        if (visited.contains(t)) {
            V p;
            long min = Long.MAX_VALUE;
            for (V v = t; !v.equals(s); v = p) {
                p = parent.get(v);
                min = Math.min(min, getCap(p, v));
            }
            for (V v = t; !v.equals(s); v = p) {
                p = parent.get(v);
                setCap(p, v, getCap(p, v) - min);
                setCap(v, p, getCap(v, p) + min);
            }
            return min;
        }
        return 0;
    }

    private Map<V, Long> get(V from) {
        Map<V, Long> map = capMap.get(from);
        if (map == null)
            capMap.put(from, map = new HashMap<>());
        return map;
    }

    private long getCap(V from, V to) {
        return get(from).getOrDefault(to, 0L);
    }

    public long runFordFulkerson(V s, V t) {
        long flow, maxflow = 0;
        while ((flow = bfs(s, t)) > 0) {
            maxflow += flow;
        }
        return maxflow;
    }

    private void setCap(V from, V to, long cap) {
        get(from).put(to, cap);
    }
}

// src/notebook/graph/TopologicalSort.java
public class TopologicalSort<V> {

    private final class Node {
        V data;

        List<Node> in = new ArrayList<>(), out = new ArrayList<>();

        Node(V data) {
            this.data = data;
        }

        @Override
        public boolean equals(Object o) {
            if (o instanceof TopologicalSort.Node) {
                @SuppressWarnings("unchecked")
                Node n = (Node) o;
                return n.data == data;
            }
            return false;
        }

        @Override
        public String toString() {
            return String.valueOf(data);
        }
    }

    private Map<V, Node> map = new HashMap<>();

    private int size = 0;

    public void addEdge(V from, V to) {
        node(from).out.add(node(to));
        node(to).in.add(node(from));
    }

    /**
     * Finds all possible solutions of topological sort
     */
    public List<List<V>> getAllSorted() {
        List<List<V>> all = new ArrayList<>();
        List<Node> fromList = new LinkedList<>();
        List<Node> sortList = new LinkedList<>();
        HashMap<Node, Integer> in = new HashMap<>();
        for (Node n : nodes()) {
            in.put(n, n.in.size());
            if (n.in.size() == 0)
                fromList.add(n);
        }
        getAllSorted(all, fromList, sortList, in);
        return all;
    }

    private void getAllSorted(List<List<V>> all, List<Node> fromList, List<Node> sortList, HashMap<Node, Integer> in) {
        if (fromList.isEmpty()) {
            all.add(sortList.stream().map(n -> n.data).collect(Collectors.toList()));
        } else {
            for (int i = 0; i < fromList.size(); i++) {
                List<Node> copySortList = new LinkedList<>(sortList);
                List<Node> copyFromList = new LinkedList<>(fromList);
                HashMap<Node, Integer> copyInMap = new HashMap<>(in);
                Node from = copyFromList.remove(i);
                copySortList.add(from);
                for (Node to : from.out) {
                    int inCount = copyInMap.get(to) - 1;
                    if (inCount == 0)
                        copyFromList.add(to);
                    else
                        copyInMap.put(to, inCount);
                }
                getAllSorted(all, copyFromList, copySortList, copyInMap);
            }
        }
    }

    public Collection<Node> getSortedBFS() {
        List<Node> sorted = new ArrayList<>(size());
        Queue<Node> queue = new LinkedList<>();
        HashMap<Node, Integer> in = new HashMap<>();
        for (Node n : nodes()) {
            in.put(n, n.in.size());
            if (n.in.size() == 0)
                queue.offer(n);
        }
        while (!queue.isEmpty()) {
            Node from = queue.poll();
            sorted.add(from);
            for (Node to : from.out) {
                int inCount = in.get(to) - 1;
                if (inCount == 0)
                    queue.offer(to);
                else
                    in.put(to, inCount);
            }
        }
        return sorted;
    }

    public Collection<Node> getSortedDFS() {
        Deque<Node> deque = new LinkedList<>();
        Set<Node> stacked = new LinkedHashSet<>();
        Set<Node> visited = new HashSet<>();
        for (Node n : nodes()) {
            if (!getSortedDFS(deque, stacked, visited, n)) {
                System.err.println("cycle: " + deque);
                return deque;
            }
        }
        return deque;
    }

    /**
     * @return true if there is no cycle, false otherwise
     */
    private boolean getSortedDFS(Deque<Node> deque, Set<Node> stacked, Set<Node> visited, Node node) {
        if (stacked.contains(node)) {
            deque.clear();
            deque.addAll(stacked);
            while (!deque.peek().equals(node))
                deque.remove();
            return false;
        }
        if (visited.contains(node))
            return true;
        stacked.add(node);
        visited.add(node);
        for (Node out : node.out)
            if (!getSortedDFS(deque, stacked, visited, out))
                return false;
        deque.addFirst(node);
        stacked.remove(node);
        return true;
    }

    private Node node(V key) {
        if (map.containsKey(key))
            return map.get(key);
        Node node = new Node(key);
        map.put(key, node);
        size++;
        return node;
    }

    public Collection<Node> nodes() {
        return map.values();
    }

    public int size() {
        return size;
    }

}

// src/notebook/interval/MergeIntervals.java
public static List<Interval> merge(List<Interval> intervals) {
    if (intervals.size() <= 1)
        return intervals;
    Collections.sort(intervals, (a, b) -> a.start - b.start);
    List<Interval> list = new LinkedList<>();
    int start = intervals.get(0).start, end = intervals.get(0).end;
    for (Interval i : intervals) {
        if (i.start <= end)
            end = Math.max(end, i.end); // next interval could be inside previous interval
        else {
            // previous merge complete
            list.add(new Interval(start, end));
            // next merge
            start = i.start;
            end = i.end;
        }
    }
    list.add(new Interval(start, end));
    return list;
}

// src/notebook/list/CycleDection.java
/**
 * @return index where cycle starts
 */
public static int detect(ListNode head) {
    ListNode slow = head.next, fast = slow.next;
    while (fast != slow) {
        fast = fast.next.next;
        slow = slow.next;
    }
    int index = 0;
    fast = head;
    while (fast != slow) {
        fast = fast.next;
        slow = slow.next;
        index++;
    }
    return index;
}

// src/notebook/math/EulerTotient.java
/**
 * @return number of positive integers < n that are relatively prime to n
 */
public static long phi(long n) {
    long r = n;
    for (long p = 2; p * p <= n; p++) {
        if (n % p == 0) {
            while (n % p == 0)
                n /= p;
            r -= r / p;
        }
    }
    if (n > 1)
        r -= r / n;
    return r;
}

// src/notebook/math/Fibonacci.java
/**
 * Calculates correct result up to n = 70
 */
public static long fib_math(int n) {
    double sqrt5 = Math.sqrt(5), golden = (1 + sqrt5) / 2;
    return (long) Math.round(Math.pow(golden, n) / sqrt5);
}

// src/notebook/math/Newton.java
/**
 * f(x) = x^2 - n = 0, f'(x) = 2x <br>
 * Iterating x = x - f/f' = x - (x^2 - n) / 2x until x does not change
 */
public static double sqrt(double n) {
    double x = n, next;
    while (true) {
        next = x - (x * x - n) / (2 * x);
        if (isNaN(next) || Math.abs(next - x) < DELTA)
            break;
        x = next;
    }
    return x;
}

// src/notebook/permutation/NextPermutation.java
public void nextPermutation(int... nums) {
    int i = nums.length - 1;
    while (i > 0 && nums[i] <= nums[i - 1])
        i--;
    if (i == 0)
        reverse(nums, 0, nums.length - 1);
    else {
        int j = nums.length - 1;
        while (nums[j] <= nums[i - 1])
            j--;
        swap(nums, i - 1, j);
        reverse(nums, i, nums.length - 1);
    }
}

// src/notebook/permutation/Permutations.java
/**
 * @return all k-permutations of [0...n-1]
 */
public static List<List<Integer>> permutations(int n, int k) {
    Queue<List<Integer>> q = new LinkedList<>(Arrays.asList(new ArrayList<>()));
    Queue<List<Integer>> r = new LinkedList<>(Arrays.asList(new ArrayList<>()));
    for (int i = 0; i < n; i++)
        r.peek().add(i);
    while (q.peek().size() < k) {
        List<Integer> qq = q.poll();
        List<Integer> rr = r.poll();
        for (int i = 0; i < rr.size(); i++) {
            List<Integer> copyqq = new ArrayList<>(qq);
            List<Integer> copyrr = new ArrayList<>(rr);
            copyqq.add(copyrr.remove(i));
            q.offer(copyqq);
            r.offer(copyrr);
        }
    }
    return new ArrayList<>(q);
}

// src/notebook/prime/Factorization.java
public static List<Long> factorize(long n) {
    List<Long> factors = new ArrayList<>();
    for (long f = 2; f * f <= n; f++) { // using (f < n) is slower
        while (n % f == 0) {
            factors.add(f);
            n /= f;
        }
    }
    if (n > 1)
        factors.add(n);
    return factors;
}

// src/notebook/prime/PrimeUtil.java
public static List<Integer> primes(int n) {
    List<Integer> primes = new ArrayList<>();
    boolean[] isComposite = new boolean[n];
    for (int i = 2; i < n; i++) {
        if (!isComposite[i]) {
            primes.add(i);
            for (int j = 2; i * j < n; j++)
                isComposite[i * j] = true;
        }
    }
    return primes;
}

// src/notebook/queue/MedianQueue.java
/**
 * Data structure that keeps track of median
 */
public class MedianQueue {

    Queue<Long> maxHeap = new PriorityQueue<>(Collections.reverseOrder()), minHeap = new PriorityQueue<>();

    public void add(long n) {
        maxHeap.add(n);
        minHeap.add(maxHeap.poll());
    }

    public double median() {
        while (maxHeap.size() - minHeap.size() >= 2)
            minHeap.offer(maxHeap.poll());
        while (minHeap.size() - maxHeap.size() >= 1)
            maxHeap.offer(minHeap.poll());
        return maxHeap.size() == minHeap.size() ? (maxHeap.peek() + minHeap.peek()) / 2.0 : maxHeap.peek();
    }

    public boolean remove(long n) {
        return maxHeap.remove(n) || minHeap.remove(n);
    }

}

// src/notebook/search/SearchUtil.java
public static int binarySearchBiasL(int[] arr, int key) {
    int l = -1, h = arr.length - 1;
    while (l < h - 1) {
        int m = (l + h) >>> 1;
        if (arr[m] >= key)
            h = m;
        else
            l = m;
    }
    return h;

}

// src/notebook/search/SearchUtil.java
public static int binarySearchBiasR(int[] arr, int key) {
    int l = 0, h = arr.length;
    while (l < h - 1) {
        int m = (l + h) >>> 1;
        if (arr[m] <= key)
            l = m;
        else
            h = m;
    }
    return l;
}

// src/notebook/set/Subsets.java
public static List<List<Integer>> subsets(int... nums) {
    List<List<Integer>> subsets = new ArrayList<>(Arrays.asList(new ArrayList<>()));
    for (int i = 0, size = subsets.size(); i < nums.length; i++, size = subsets.size()) {
        for (int j = 0; j < size; j++) {
            List<Integer> l = new ArrayList<>(subsets.get(j));
            l.add(nums[i]);
            subsets.add(l);
        }
    }
    return subsets;
}

// src/notebook/set/Subsets.java
/**
 * The given set may contain duplicates. <br>
 * The solution must not contain duplicates.
 */
public static List<List<Integer>> subsetsWithDup(int... nums) {
    Arrays.sort(nums);
    List<List<Integer>> subsets = new ArrayList<>(Arrays.asList(new ArrayList<>()));
    for (int i = 0, presize = 0, cursize = subsets
            .size(); i < nums.length; i++, presize = cursize, cursize = subsets.size()) {
        for (int j = i == 0 || nums[i] != nums[i - 1] ? 0 : presize; j < cursize; j++) {
            List<Integer> subset = new ArrayList<>(subsets.get(j));
            subset.add(nums[i]);
            subsets.add(subset);
        }
    }
    return subsets;
}

// src/notebook/set/SubsetSum.java
/**
 * @return number of subsets whose sum is k
 */
public int subsetSum(int[] nums, int k) {
    int[] dp = new int[k + 1];
    dp[0] = 1;
    for (int n : nums)
        for (int i = k; i >= n; i--)
            dp[i] += dp[i - n];
    return dp[k];
}

// src/notebook/string/EditDistance.java
public static int minDistance(String s, String t) {
    int m = s.length();
    int n = t.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 0; i <= m; i++)
        dp[i][0] = i;
    for (int j = 0; j <= n; j++)
        dp[0][j] = j;
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++)
            if (s.charAt(i - 1) == t.charAt(j - 1))
                dp[i][j] = dp[i - 1][j - 1];
            else
                dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1]));
    return dp[m][n];
}

// src/notebook/string/FormatTest.java
@Test
public void test() {
    // rounded to 4th
    assertEquals("0.1235", String.format("%.4f", 0.12345));

    // add 0's to end
    assertEquals("0.1000", String.format("%.4f", 0.1));

    // add 0's to begin
    assertEquals("0012", String.format("%04d", 12));

    // rounded
    assertEquals("00.14", new DecimalFormat("00.00").format(0.135));
}

// src/notebook/tree/SegmentTree.java
public class SegmentTree {

    final class Node {
        final Node left, right;
        final int begin, end;
        long sum;

        Node(Node left, Node right, int begin, int end, long sum) {
            this.left = left;
            this.right = right;
            this.begin = begin;
            this.end = end;
            this.sum = sum;
        }
    }

    final Node root;

    public SegmentTree(int... arr) {
        root = buildTree(arr, 0, arr.length);
    }

    private Node buildTree(int[] arr, int b, int e) {
        if (arr.length == 0)
            return null;
        if (b + 1 == e)
            return new Node(null, null, b, e, arr[b]);
        int m = (b + e) >>> 1;
        Node l = buildTree(arr, b, m);
        Node r = buildTree(arr, m, e);
        return new Node(l, r, b, e, l.sum + r.sum);
    }

    /**
     * @param begin
     *            index inclusive
     * @param end
     *            index exclusive
     * @return sum in [begin, end)
     */
    public long sum(int begin, int end) {
        return sumRec(root, begin, end);
    }

    private long sumRec(Node root, int begin, int end) {
        if (root == null || root.end < begin || end < root.begin)
            return 0;
        if (begin <= root.begin && root.end <= end)
            return root.sum;
        return sumRec(root.left, begin, end) + sumRec(root.right, begin, end);
    }

    public void update(int i, int value) {
        updateRec(root, i, value);
    }

    private void updateRec(Node root, int i, int value) {
        if (root.begin == i && i + 1 == root.end)
            root.sum = value;
        else if (root.begin <= i && i < root.end) {
            updateRec(root.left, i, value);
            updateRec(root.right, i, value);
            root.sum = root.left.sum + root.right.sum;
        }
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        toStringAsTree(sb, root, 0);
        return sb.toString();
    }

    private void toStringAsTree(StringBuilder sb, Node root, int depth) {
        if (root == null)
            return;
        for (int i = 0; i < depth; i++)
            sb.append(' ');
        String nodeInfo = "[" + root.begin + ", " + root.end + ") sum = " + root.sum;
        sb.append(nodeInfo).append('\n');
        toStringAsTree(sb, root.left, depth + 1);
        toStringAsTree(sb, root.right, depth + 1);
    }

}

