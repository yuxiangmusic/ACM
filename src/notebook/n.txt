// src/notebook/array/ArrayUtil.java
/**
 * @return i'th smallest
 */
public static <E> E ith(E[] arr, int i, Comparator<E> comp) {
    int l = 0, h = arr.length - 1;
    while (l <= h) {
        int p = partition(arr, l, h, comp);
        if (p == i)
            return arr[p];
        else if (p < i)
            l = p + 1;
        else
            h = p - 1;
    }
    return null;
}

// src/notebook/array/ArrayUtil.java
/**
 * @return (i - l)'th smallest
 */
public static <E> E ith(E[] arr, int l, int h, int i, Comparator<E> comp) {
    if (i < l || i > h)
        throw new IllegalArgumentException();
    while (l <= h) {
        int p = partition(arr, l, h, comp);
        if (p == i)
            return arr[p];
        else if (p < i)
            l = p + 1;
        else
            h = p - 1;
    }
    return null;
}

// src/notebook/array/ArrayUtil.java
/**
 * The i'th smallest, where i is 0 based
 */
public static int ith(int[] arr, int i) {
    int l = 0, h = arr.length - 1;
    while (l <= h) {
        int p = partition(arr, l, h);
        if (p == i)
            return arr[p];
        else if (p < i)
            l = p + 1;
        else
            h = p - 1;
    }
    return 0;
}

// src/notebook/array/ArrayUtil.java
/**
 * @return (i - l)'th smallest
 */
public static int ith(int[] arr, int l, int h, int i) {
    if (i < l || i > h)
        throw new IllegalArgumentException();
    while (l <= h) {
        int p = partition(arr, l, h);
        if (p == i)
            return arr[p];
        else if (p < i)
            l = p + 1;
        else
            h = p - 1;
    }
    return 0;
}

// src/notebook/array/ArrayUtil.java
public static int kthLargest(int[] arr, int k) {
    if (k > arr.length)
        throw new IllegalArgumentException();
    int l = 0, h = arr.length - 1;
    while (l <= h) {
        int p = partition(arr, l, h);
        int rank = arr.length - p;
        if (rank == k)
            return arr[p];
        else if (rank > k)
            l = p + 1;
        else
            h = p - 1;
    }
    return 0;
}

// src/notebook/array/ArrayUtil.java
public static int partition(int[] arr, int l, int h) {
    for (int i = l; i < h; i++)
        if (arr[i] < arr[h])
            swap(arr, i, l++);
    swap(arr, l, h);
    return l;
}

// src/notebook/array/LargestRectangleInHistogram.java
public static int largestRectangleArea(int[] h) {
    int n = h.length, stack[] = new int[n], size = 0, max = 0;
    if (n == 0)
        return 0;
    for (int i = 0; i <= n; i++) {
        while (size > 0 && (i == n || h[stack[size - 1]] >= h[i]))
            max = Math.max(max, h[stack[--size]] * (i - (size == 0 ? 0 : 1 + stack[size - 1])));
        stack[size++] = i;
    }
    return max;
}

// src/notebook/array/LongestIncreasingSubsequence.java
/**
 * O(n*log(n)) DP solution
 */
public static int[] getLIS_log(int... arr) {
    if (arr.length == 0)
        return new int[0];
    int len = 0, dp[] = new int[arr.length];
    int p[] = new int[arr.length];
    for (int i = 0; i < arr.length; i++) {
        int l = 0, h = len - 1;
        while (l <= h) {
            int mid = (l + h) >>> 1;
            if (arr[dp[mid]] == arr[i]) {
                l = mid;
                break;
            } else if (arr[dp[mid]] < arr[i]) {
                l = mid + 1;
            } else {
                h = mid - 1;
            }
        }
        dp[l] = i;
        if (len == l)
            len++;
        if (l > 0)
            p[i] = dp[l - 1];
    }
    int lis[] = new int[len], arrIndex = dp[len - 1];
    for (int i = len - 1; i >= 0; i--) {
        lis[i] = arr[arrIndex]; // or we can return indexes
        arrIndex = p[arrIndex];
    }
    return lis;
}

// src/notebook/array/LongestIncreasingSubsequence.java
/**
 * classic DP solution O(n^2)
 */
public static int[] getLIS_quadratic(int... arr) {
    if (arr.length == 0)
        return new int[0];
    int l[] = new int[arr.length]; // l[i] := length of LIS ending at i
    int p[] = new int[arr.length]; // p[i] := predecessor of i
    int maxIndex = 0; // index of max LIS
    for (int i = 0; i < arr.length; i++) {
        l[i] = 1;
        p[i] = -1;
        for (int j = 0; j < i; j++) {
            if (arr[j] < arr[i] && l[i] < l[j] + 1) {
                l[i] = l[j] + 1;
                p[i] = j;
            }
        }
        if (l[i] > l[maxIndex])
            maxIndex = i;
    }
    int lis[] = new int[l[maxIndex]], arrIndex = maxIndex;
    for (int i = lis.length - 1; i >= 0; i--) {
        lis[i] = arr[arrIndex]; // or we can return indexes
        arrIndex = p[arrIndex];
    }
    return lis;
}

// src/notebook/array/LongestIncreasingSubsequence.java
/**
 * @return length of LIS
 */
public static int lenLIS_log(int... arr) {
    // DP[i] := smallest tail of LIS of length (i + 1)
    int[] dp = new int[arr.length];
    int len = 0; // effective length of DP
    for (int n : arr) {
        int i = Arrays.binarySearch(dp, 0, len, n);
        if (i < 0)
            i = ~i;
        dp[i] = n;
        if (i == len)
            len++;
    }
    return len;
}

// src/notebook/array/LongestIncreasingSubsequence.java
/**
 * @return length of LIS
 */
public static int lenLIS_quadratic(int... arr) {
    if (arr.length == 0)
        return 0;
    // DP[i] := length of LIS ending at i
    int dp[] = new int[arr.length];
    int max = 0;
    for (int i = 0; i < arr.length; i++) {
        dp[i] = 1;
        for (int j = 0; j < i; j++)
            if (arr[j] < arr[i])
                dp[i] = Math.max(dp[i], 1 + dp[j]);
        max = Math.max(max, dp[i]);
    }
    return max;
}

// src/notebook/bit/GrayCode.java
public static int toBinary(int n) {
    for (int m = n >> 1; m != 0; m >>= 1)
        n = n ^ m;
    return n;
}

// src/notebook/bit/GrayCode.java
public static int toGrayCode(int n) {
    return n ^ (n >> 1);
}

// src/notebook/bit/MaximumXOR.java
/**
 * @return maximum XOR of two numbers
 */
public int findMaximumXOR(int[] nums) {
    int max = 0, mask = 0;
    for (int i = 30; i >= 0; i--) {
        int m = 1 << i;
        mask |= m;
        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num & mask);
        }
        // test if i'th bit of max can be set, given LHS bits
        int tmp = max | m;
        for (int prefix : set) {
            // there exist prefix x and y such that (x ^ y) = (max | m)
            if (set.contains(tmp ^ prefix)) {
                max = tmp;
                break;
            }
        }
    }
    return max;
}

// src/notebook/combination/Combinations.java
/**
 * @return all k-combinations of [0...n-1]
 */
public static List<List<Integer>> combinations(int n, int k) {
    Queue<List<Integer>> q = new LinkedList<>(Arrays.asList(new ArrayList<>()));
    while (q.peek().size() < k) {
        List<Integer> l = q.poll();
        int last = l.isEmpty() ? -1 : l.get(l.size() - 1);
        for (int i = last + 1; i <= n - k + l.size(); i++) {
            List<Integer> copy = new ArrayList<>(l);
            copy.add(i);
            q.offer(copy);
        }
    }
    return new ArrayList<>(q);
}

// src/notebook/combination/Combinations.java
public static long choose(int n, int k) {
    long ans = 1;
    for (int i = 0; i < k; i++) {
        ans *= (n - i);
        ans /= (1 + i);
    }
    return ans;
}

// src/notebook/gcd/ChineseRemainderTheorem.java
/**
 * @return n (MOD r*s) such that n == a (MOD r) and n == b (MOD s)
 */
public static long getN(long r, long s, long a, long b) {
    ExtendedEuclid ans = ExtendedEuclid.gcd(r, s);

    if (Math.abs(ans.gcd) != 1)
        throw new IllegalArgumentException("gcd(r, s) must be 1");

    long n = b * r * ans.x + a * s * ans.y, rs = r * s;

    return (n % rs + rs) % rs; // least positive n (MOD r*s)
}

// src/notebook/gcd/ExtendedEuclid.java
public class ExtendedEuclid {
    /**
     * @return GCD(a, b) = ax + by
     */
    public static ExtendedEuclid gcd(long a, long b) {
        ExtendedEuclid ans = new ExtendedEuclid();
        if (b == 0) {
            ans.gcd = a;
            ans.a = a;
            ans.b = b;
            ans.x = 1;
            ans.y = 0;
            return ans;
        }
        ans = gcd(b, a % b);
        long x = ans.x, y = ans.y, q = a / b;

        ans.gcd = ans.gcd;
        ans.a = a;
        ans.b = b;
        ans.x = y;
        ans.y = x - y * q;

        return ans;
    }

    public long gcd, a, x, b, y;

    @Override
    public String toString() {
        return String.format("%d = %d * %d + %d * %d", gcd, a, x, b, y);
    }

}

// src/notebook/gcd/GCD.java
public static long gcd_rec(long a, long b) {
    // add Math.abs when necessary
    return b == 0 ? a : gcd_rec(b, a % b);
}

// src/notebook/gcd/GCD.java
public static long gcd_itr(long a, long b) {
    // add Math.abs when necessary
    long r;
    while (b != 0) {
        r = a % b;
        a = b;
        b = r;
    }
    return a;
}

// src/notebook/geometry/GrahamScan.java
private static Point bottomLeft(Point[] points) {
    Point bottomLeft = points[0];
    for (Point p : points)
        if (p.y < bottomLeft.y || p.y == bottomLeft.y && p.x < bottomLeft.x)
            bottomLeft = p;
    return bottomLeft;
}

// src/notebook/geometry/GrahamScan.java
private static void sortByPolar(Point[] points, Point r) {
    Arrays.sort(points, (p, q) -> {
        int x1 = p.x - r.x;
        int y1 = p.y - r.y;
        int x2 = q.x - r.x;
        int y2 = q.y - r.y;
        int compPolar = x2 * y1 - x1 * y2;
        int compDist = (x1 * x1 + y1 * y1) - (x2 * x2 + y2 * y2);
        return compPolar == 0 ? compDist : compPolar;
    });
}

// src/notebook/geometry/GrahamScan.java
public static Point[] runGrahamScan(Point... points) {
    if (points.length <= 1)
        return points;
    Point bottomLeft = bottomLeft(points);
    sortByPolar(points, bottomLeft);
    Stack<Point> stack = new Stack<>();
    int i = 0;
    stack.push(points[i++]);
    stack.push(points[i++]);
    for (; i < points.length; i++) {
        if (ccw(points[0], points[1], points[i]) == 0) {
            stack.pop(); // skip mid point on the same line
            stack.push(points[i]);
        } else {
            break;
        }
    }
    for (; i < points.length; i++) {
        Point top = stack.pop();
        while (ccw(stack.peek(), top, points[i]) <= 0)
            top = stack.pop();
        stack.push(top);
        stack.push(points[i]);
    }
    return stack.stream().toArray(Point[]::new);
}

// src/notebook/geometry/LineUtil.java
/**
 * @see {@link java.awt.geom.Line2D#linesIntersect(double, double, double, double, double, double, double, double)}
 */
public static boolean linesIntersect(double x1, double y1, double x2, double y2, double x3, double y3, double x4,
        double y4) {
    return ((relativeCCW(x1, y1, x2, y2, x3, y3) * relativeCCW(x1, y1, x2, y2, x4, y4) <= 0)
            && (relativeCCW(x3, y3, x4, y4, x1, y1) * relativeCCW(x3, y3, x4, y4, x2, y2) <= 0));
}

// src/notebook/geometry/LineUtil.java
/**
 * @see {@link java.awt.geom.Line2D#ptLineDist(double, double)}
 */
public static double ptLineDist(double x1, double y1, double x2, double y2, double px, double py) {
    return Math.sqrt(ptLineDistSq(x1, y1, x2, y2, px, py));
}

// src/notebook/geometry/LineUtil.java
/**
 * @see {@link java.awt.geom.Line2D#ptLineDistSq(double, double)}
 */
public static double ptLineDistSq(double x1, double y1, double x2, double y2, double px, double py) {
    x2 -= x1;
    y2 -= y1;
    px -= x1;
    py -= y1;
    double dotprod = px * x2 + py * y2;
    double projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
    double lenSq = px * px + py * py - projlenSq;
    if (lenSq < 0) {
        lenSq = 0;
    }
    return lenSq;
}

// src/notebook/geometry/LineUtil.java
/**
 * @see {@link java.awt.geom.Line2D#ptSegDist(double, double)}
 */
public static double ptSegDist(double x1, double y1, double x2, double y2, double px, double py) {
    return Math.sqrt(ptSegDistSq(x1, y1, x2, y2, px, py));
}

// src/notebook/geometry/LineUtil.java
/**
 * @see {@link java.awt.geom.Line2D#ptSegDistSq(double, double)}
 */
public static double ptSegDistSq(double x1, double y1, double x2, double y2, double px, double py) {
    x2 -= x1;
    y2 -= y1;
    px -= x1;
    py -= y1;
    double dotprod = px * x2 + py * y2;
    double projlenSq;
    if (dotprod <= 0.0) {
        projlenSq = 0.0;
    } else {
        px = x2 - px;
        py = y2 - py;
        dotprod = px * x2 + py * y2;
        if (dotprod <= 0.0) {
            projlenSq = 0.0;
        } else {
            projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
        }
    }
    double lenSq = px * px + py * py - projlenSq;
    if (lenSq < 0) {
        lenSq = 0;
    }
    return lenSq;
}

// src/notebook/geometry/LineUtil.java
/**
 * @see {@link java.awt.geom.Line2D#relativeCCW(double, double, double, double, double, double)}
 */
public static int relativeCCW(double x1, double y1, double x2, double y2, double px, double py) {
    x2 -= x1;
    y2 -= y1;
    px -= x1;
    py -= y1;
    double ccw = px * y2 - py * x2;
    if (ccw == 0.0) {
        ccw = px * x2 + py * y2;
        if (ccw > 0.0) {
            px -= x2;
            py -= y2;
            ccw = px * x2 + py * y2;
            if (ccw < 0.0) {
                ccw = 0.0;
            }
        }
    }
    return (ccw < 0.0) ? -1 : ((ccw > 0.0) ? 1 : 0);
}

// src/notebook/geometry/PointUtil.java
/**
 * @return positive if counter-clockwise, negative if clockwise, 0 otherwise
 */
public static int ccw(Point a, Point b, Point c) {
    return a.x * b.y - a.y * b.x + b.x * c.y - b.y * c.x + c.x * a.y - c.y * a.x;
}

// src/notebook/geometry/PolygonUtil.java
/**
 * @param p
 *            points sorted in counter-clockwise order
 * @return area of the polygon
 */
public static double area(Point... p) {
    int a = 0, j = p.length - 1;
    for (int i = 0; i < p.length; j = i++)
        a += (p[i].x + p[j].x) * (p[i].y - p[j].y);
    return a / 2.0;
}

// src/notebook/geometry/PolygonUtil.java
public static boolean contains(Point[] p, Point test) {
    int i, j;
    boolean contains = false;
    for (i = 0, j = p.length - 1; i < p.length; j = i++)
        if ((p[i].y > test.y) != (p[j].y > test.y)
                && (test.x < (p[j].x - p[i].x) * (test.y - p[i].y) / (p[j].y - p[i].y) + p[i].x))
            contains = !contains;
    return contains;
}

// src/notebook/geometry/TriangleUtil.java
public static double area(double a, double b, double c) {
    double s = semiPerimeter(a, b, c);
    double areaSq = s * (s - a) * (s - b) * (s - c);
    return Math.sqrt(areaSq);
}

// src/notebook/geometry/TriangleUtil.java
public static double circumcircleRadius(double a, double b, double c) {
    return a * b * c / Math.sqrt((a + b + c) * (b + c - a) * (a + c - b) * (a + b - c));
}

// src/notebook/geometry/TriangleUtil.java
/**
 * @return radius of excircle touching a
 */
public static double excircleRadius(double a, double b, double c) {
    double s = semiPerimeter(a, b, c);
    double radiusSq = s * (s - b) * (s - c) / (s - a);
    return Math.sqrt(radiusSq);
}

// src/notebook/geometry/TriangleUtil.java
public static double incircleRadius(double a, double b, double c) {
    return area(a, b, c) / semiPerimeter(a, b, c);
}

// src/notebook/geometry/TriangleUtil.java
public static double semiPerimeter(double a, double b, double c) {
    return (a + b + c) / 2;
}

// src/notebook/graph/BellmanFord.java
public static int[] runBellmanFord(int[][] graph, int s) {
    int[] dist = new int[graph.length];
    Arrays.fill(dist, INFINITY);
    dist[s] = 0;
    int n = graph.length;
    boolean updated = false;
    for (int step = 0; step < n; step++, updated = false) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                // for each edge (more efficient if we have a list of edges)
                if (dist[i] != INFINITY && graph[i][j] != INFINITY) {
                    int alt = dist[i] + graph[i][j];
                    if (alt < dist[j]) {
                        if (step == n - 1)
                            throw new RuntimeException("negative cycle");
                        dist[j] = alt;
                        updated = true;
                    }
                }
            }
        }
        if (!updated)
            break;
    }
    return dist;
}

// src/notebook/graph/BipartiteMatching.java
/**
 * @param graph
 *            - graph[i][j] := source i to sink j
 * @return max number of matchings
 */
public static int matchDFS(boolean[][] graph) {
    int m = graph.length; // source
    int n = graph[0].length; // sink
    int[] back = new int[n]; // back edges
    Arrays.fill(back, -1);

    int match = 0;
    for (int s = 0; s < m; s++) {
        if (matchDFS(graph, new boolean[n], back, s)) {
            match++;
        }
    }
    return match;
}

// src/notebook/graph/BipartiteMatching.java
private static boolean matchDFS(boolean[][] graph, boolean[] visited, int[] back, int s) {
    int n = graph[0].length; // sink
    for (int t = 0; t < n; t++) {
        if (graph[s][t] && !visited[t]) {
            visited[t] = true;
            // s can match t, or back[t] can match something else
            if (back[t] < 0 || matchDFS(graph, visited, back, back[t])) {
                back[t] = s;
                return true;
            }
        }
    }
    return false;
}

// src/notebook/graph/Dijkstra.java
public static int runDijkstra(int[][] graph, int s, int t) {
    int[] dist = new int[graph.length];
    Arrays.fill(dist, INFINITY);
    dist[s] = 0;

    Queue<Integer> pq = new PriorityQueue<>((p, q) -> dist[p] - dist[q]);
    pq.offer(s);
    while (!pq.isEmpty()) {
        int p = pq.poll();
        if (p == t)
            return dist[p];
        // for each neighbor of p
        for (int q = 0; q < graph.length; q++) {
            if (graph[p][q] != INFINITY) {
                int alt = dist[p] + graph[p][q];
                if (alt < dist[q]) {
                    dist[q] = alt;
                    pq.offer(q);
                }
            }
        }
    }
    return INFINITY;
}

// src/notebook/graph/DijkstraSolver.java
public class DijkstraSolver<V> {

    private static final Integer INFINITY = Integer.MAX_VALUE;

    private final Map<V, Map<V, Integer>> costMap = new HashMap<>();

    private final Map<V, Integer> distMap = new HashMap<>();

    public void addEdge(V from, V to, int cost) {
        get(from).put(to, cost);
    }

    public int runDijkstra(V s, V t) {
        distMap.clear();
        distMap.put(s, 0);

        Queue<V> pq = new PriorityQueue<>((p, q) -> Integer.compare(dist(p), dist(q)));
        pq.offer(s);

        while (!pq.isEmpty()) {
            V cur = pq.poll();
            int curDist = dist(cur);
            if (cur.equals(t))
                return curDist;

            for (Map.Entry<V, Integer> entry : costMap.get(cur).entrySet()) {
                V neighbor = entry.getKey();
                int neighborCost = entry.getValue();
                int neighborDist = dist(neighbor);
                int altDist = curDist + neighborCost;
                if (altDist < neighborDist) {
                    distMap.put(neighbor, altDist);
                    pq.offer(neighbor);
                }
            }
        }
        return INFINITY;
    }

    private int dist(V v) {
        return distMap.getOrDefault(v, INFINITY);
    }

    private Map<V, Integer> get(V from) {
        Map<V, Integer> map = costMap.get(from);
        if (map == null)
            costMap.put(from, map = new HashMap<>());
        return map;
    }

}

// src/notebook/graph/FloydWarshall.java
public static int[][] runFloydWarshall(int[][] graph) {
    int n = graph.length;
    int[][] dist = new int[n][n];

    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            dist[i][j] = graph[i][j];

    for (int k = 0; k < n; k++)
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);

    return dist;
}

// src/notebook/graph/MaxFlow.java
public static int runFordFulkerson(int[][] graph, int s, int t) {
    int maxFlow = 0, parent[] = new int[graph.length];
    while (bfs(graph, s, t, parent)) {
        int p, min = Integer.MAX_VALUE;
        for (int v = t; v != s; v = p) {
            p = parent[v];
            min = Math.min(min, graph[p][v]);
        }
        for (int v = t; v != s; v = p) {
            p = parent[v];
            graph[p][v] -= min;
            graph[v][p] += min;
        }
        maxFlow += min;
    }
    return maxFlow;
}

// src/notebook/graph/MaxFlow.java
private static boolean bfs(int[][] graph, int s, int t, int[] parent) {
    Queue<Integer> q = new LinkedList<>();
    q.offer(s);

    boolean[] visited = new boolean[graph.length];

    while (!q.isEmpty()) {
        int v = q.poll();
        visited[v] = true;
        if (v == t)
            break;
        for (int w = 0; w < graph.length; w++) {
            if (graph[v][w] > 0 && !visited[w]) {
                q.offer(w);
                parent[w] = v;
            }
        }
    }
    return visited[t];
}

// src/notebook/graph/MaxFlowSolver.java
public class MaxFlowSolver<V> {

    private final Map<V, Map<V, Integer>> capMap = new HashMap<>();

    public void addEdge(V from, V to, int cap) {
        get(from).put(to, cap);
    }

    private boolean bfs(V s, V t, Map<V, V> parent) {
        Queue<V> q = new LinkedList<>();
        q.offer(s);

        Set<V> visited = new HashSet<>();

        while (!q.isEmpty()) {
            V v = q.poll();
            visited.add(v);
            if (v.equals(t))
                break;
            for (Map.Entry<V, Integer> entry : get(v).entrySet()) {
                V w = entry.getKey();
                if (entry.getValue() > 0 && !visited.contains(w)) {
                    q.offer(w);
                    parent.put(w, v);
                }
            }
        }
        return visited.contains(t);
    }

    private Map<V, Integer> get(V from) {
        Map<V, Integer> map = capMap.get(from);
        if (map == null)
            capMap.put(from, map = new HashMap<>());
        return map;
    }

    private int getCap(V from, V to) {
        return get(from).getOrDefault(to, 0);
    }

    public int runFordFulkerson(V s, V t) {
        int maxFlow = 0;
        Map<V, V> parent = new HashMap<>();
        while (bfs(s, t, parent)) {
            V p;
            int min = Integer.MAX_VALUE;
            for (V v = t; !v.equals(s); v = p) {
                p = parent.get(v);
                min = Math.min(min, getCap(p, v));
            }
            for (V v = t; !v.equals(s); v = p) {
                p = parent.get(v);
                setCap(p, v, getCap(p, v) - min);
                setCap(v, p, getCap(v, p) + min);
            }
            maxFlow += min;
        }
        return maxFlow;
    }

    private void setCap(V from, V to, int cap) {
        get(from).put(to, cap);
    }
}

// src/notebook/graph/MinimumSpanningTree.java
/**
 * @param graph
 *            - undirected graph
 * @return minimum spanning tree
 */
public static int[][] runKruskal(int[][] graph) {
    int n = graph.length;

    List<int[]> edges = new ArrayList<>();
    // get all edges
    for (int i = 0; i < n; i++)
        for (int j = i + 1; j < n; j++)
            edges.add(new int[] { i, j });

    // sort edges
    edges.sort((a, b) -> graph[a[0]][a[1]] - graph[b[0]][b[1]]);

    // union find
    int[] parent = new int[n], height = new int[n];
    for (int i = 0; i < n; i++)
        parent[i] = i;

    Function<Integer, Integer> find = i -> {
        while (i != parent[i])
            i = parent[i];
        return i;
    };

    int ans[][] = new int[n - 1][], size = 0;
    for (int[] edge : edges) {
        // union x and y
        int x = edge[0];
        int y = edge[1];
        int xset = find.apply(x);
        int yset = find.apply(y);
        if (xset != yset) {
            if (height[xset] > height[yset]) {
                parent[xset] = yset;
                height[yset]++;
            } else {
                parent[yset] = xset;
                height[xset]++;
            }
            ans[size++] = edge;
        }
    }
    return ans;
}

// src/notebook/graph/TopologicalSort.java
/**
 * Topologically sorts n nodes labeled from 0 to (n - 1)
 */
public static int[] sortBFS(int n, int[][] edges) {
    // adjacent list
    List<List<Integer>> adj = new ArrayList<>(n);
    for (int i = 0; i < n; i++)
        adj.add(new ArrayList<>());

    // in-degrees
    int[] in = new int[n];
    for (int[] edge : edges) {
        in[edge[1]]++;
        adj.get(edge[0]).add(edge[1]);
    }

    int ans[] = new int[adj.size()], size = 0;
    Queue<Integer> q = new LinkedList<>();
    for (int i = 0; i < adj.size(); i++)
        if (in[i] == 0)
            q.offer(i);
    while (!q.isEmpty()) {
        int from = q.poll();
        ans[size++] = from;
        for (int to : adj.get(from))
            if (--in[to] == 0)
                q.offer(to);
    }
    return size == adj.size() ? ans : new int[0];
}

// src/notebook/graph/TopologicalSort.java
/**
 * Topologically sorts n nodes labeled from 0 to (n - 1)
 */
public static int[] sortDFS(int n, int[][] edges) {
    // adjacent list
    List<List<Integer>> adj = new ArrayList<>(n);
    for (int i = 0; i < n; i++)
        adj.add(new ArrayList<>());
    for (int[] edge : edges)
        adj.get(edge[0]).add(edge[1]);

    Stack<Integer> stack = new Stack<>();
    boolean[] stacked = new boolean[adj.size()];
    boolean[] visited = new boolean[adj.size()];
    for (int i = 0; i < adj.size(); i++)
        if (!sortDFS(stack, stacked, visited, i, adj))
            return new int[0];

    int ans[] = new int[n];
    for (int i = 0; i < ans.length; i++)
        ans[i] = stack.pop();
    return ans;
}

// src/notebook/graph/TopologicalSort.java
private static boolean sortDFS(Stack<Integer> stack, boolean[] stacked, boolean[] visited, int v,
        List<List<Integer>> adj) {
    if (stacked[v]) // check stacked 1st
        return false;
    if (visited[v]) // check visited 2nd
        return true;
    // start visiting
    stacked[v] = true;
    visited[v] = true;
    for (int to : adj.get(v))
        if (!sortDFS(stack, stacked, visited, to, adj))
            return false;
    stack.push(v);
    stacked[v] = false;
    return true;
}

// src/notebook/graph/TopologicalSorter.java
public class TopologicalSorter<V> {
    /**
     * Adjacent list
     */
    private final Map<V, List<V>> adj = new HashMap<>();
    /**
     * In-degrees, needed only by BFS
     */
    private final Map<V, Integer> in = new HashMap<>();

    public void addEdge(V from, V to) {
        // make sure in-degree map has all vertexes stored
        if (!in.containsKey(from))
            in.put(from, 0);
        if (!in.containsKey(to))
            in.put(to, 0);

        adj(from).add(to);
        in.put(to, 1 + in.getOrDefault(to, 0));
    }

    private List<V> adj(V v) {
        List<V> list = adj.get(v);
        if (list == null)
            adj.put(v, list = new ArrayList<>());
        return list;
    }

    public List<V> sortBFS() {
        List<V> sorted = new ArrayList<>();
        Queue<V> q = new LinkedList<>();

        // create a copy to avoid modifying the original in-degree map
        Map<V, Integer> in = new HashMap<>(this.in);

        for (Map.Entry<V, Integer> entry : in.entrySet()) {
            V v = entry.getKey();
            int degree = entry.getValue();
            if (degree == 0)
                q.offer(v);
        }
        while (!q.isEmpty()) {
            V from = q.poll();
            sorted.add(from);
            for (V to : adj(from)) {
                int indegree = in.get(to) - 1;
                if (indegree == 0)
                    q.offer(to);
                in.put(to, indegree);
            }
        }
        return sorted;
    }

    public List<V> sortDFS() {
        Stack<V> stack = new Stack<>();
        Set<V> stacked = new LinkedHashSet<>();
        Set<V> visited = new HashSet<>();
        for (V n : adj.keySet()) {
            if (!sortDFS(stack, stacked, visited, n)) {
                System.err.println("cycle: " + stack);
                return new ArrayList<>(stack);
            }
        }

        // get sorted list
        List<V> sorted = new ArrayList<>();
        while (!stack.isEmpty())
            sorted.add(stack.pop());
        return sorted;
    }

    /**
     * @return true if there is no cycle, false otherwise
     */
    private boolean sortDFS(Stack<V> stack, Set<V> stacked, Set<V> visited, V v) {
        // cycle found
        if (stacked.contains(v)) {
            stack.clear();
            stack.addAll(stacked);
            while (!stack.peek().equals(v))
                stack.pop();
            return false;
        }
        if (visited.contains(v))
            return true;

        // start visiting
        stacked.add(v);
        visited.add(v);
        for (V out : adj(v))
            if (!sortDFS(stack, stacked, visited, out))
                return false;
        stack.push(v);
        stacked.remove(v);
        return true;
    }

    /**
     * Gets all topologically sorted lists
     */
    public List<List<V>> sortGetAll() {
        List<List<V>> all = new ArrayList<>();
        List<V> sortedList = new LinkedList<>();
        List<V> zeroinList = new LinkedList<>();

        for (Map.Entry<V, Integer> entry : in.entrySet()) {
            V v = entry.getKey();
            int degree = entry.getValue();
            if (degree == 0)
                zeroinList.add(v);
        }
        sortGetAll(all, sortedList, zeroinList, in);
        return all;
    }

    private void sortGetAll(List<List<V>> all, List<V> sortedList, List<V> zeroinList, Map<V, Integer> in) {
        if (zeroinList.isEmpty()) {
            all.add(sortedList);
            return;
        }
        for (int i = 0; i < zeroinList.size(); i++) {
            List<V> sortedListCopy = new LinkedList<>(sortedList);
            List<V> zeroinListCopy = new LinkedList<>(zeroinList);
            Map<V, Integer> inCopy = new HashMap<>(in);

            V from = zeroinListCopy.remove(i);
            sortedListCopy.add(from);

            for (V to : adj.get(from)) {
                int indegree = inCopy.get(to) - 1;
                if (indegree == 0)
                    zeroinListCopy.add(to);
                inCopy.put(to, indegree);
            }
            sortGetAll(all, sortedListCopy, zeroinListCopy, inCopy);
        }
    }

}

// src/notebook/interval/MergeIntervals.java
public static List<Interval> merge(List<Interval> intervals) {
    if (intervals.size() <= 1)
        return intervals;
    Collections.sort(intervals, (a, b) -> a.start - b.start);
    List<Interval> list = new LinkedList<>();
    int start = intervals.get(0).start, end = intervals.get(0).end;
    for (Interval i : intervals) {
        if (i.start <= end)
            end = Math.max(end, i.end); // next interval could be inside previous interval
        else {
            // previous merge complete
            list.add(new Interval(start, end));
            // next merge
            start = i.start;
            end = i.end;
        }
    }
    list.add(new Interval(start, end));
    return list;
}

// src/notebook/list/CycleDection.java
/**
 * @return index where cycle starts
 */
public static int detect(ListNode head) {
    ListNode slow = head.next, fast = slow.next;
    while (fast != slow) {
        fast = fast.next.next;
        slow = slow.next;
    }
    int index = 0;
    fast = head;
    while (fast != slow) {
        fast = fast.next;
        slow = slow.next;
        index++;
    }
    return index;
}

// src/notebook/math/EulerTotient.java
/**
 * @return number of positive integers < n that are relatively prime to n
 */
public static long phi(long n) {
    long r = n;
    for (long p = 2; p * p <= n; p++) {
        if (n % p == 0) {
            while (n % p == 0)
                n /= p;
            r -= r / p;
        }
    }
    if (n > 1)
        r -= r / n;
    return r;
}

// src/notebook/math/Fibonacci.java
/**
 * Calculates correct result up to n = 70
 */
public static long fib_math(int n) {
    double sqrt5 = Math.sqrt(5), golden = (1 + sqrt5) / 2;
    return (long) Math.round(Math.pow(golden, n) / sqrt5);
}

// src/notebook/math/Newton.java
/**
 * f(x) = x^2 - n = 0, f'(x) = 2x <br>
 * Iterating x = x - f/f' = x - (x^2 - n) / 2x until x does not change
 */
public static double sqrt(double n) {
    double x = n, next;
    while (true) {
        next = x - (x * x - n) / (2 * x);
        if (Double.isNaN(next) || Math.abs(next - x) < DELTA)
            break;
        x = next;
    }
    return x;
}

// src/notebook/permutation/NextPermutation.java
public static void nextPermutation(int... nums) {
    int i = nums.length - 1;
    while (i > 0 && nums[i] <= nums[i - 1])
        i--;
    if (i == 0) {
        reverse(nums, 0, nums.length - 1);
        return;
    }
    int j = nums.length - 1;
    while (nums[j] <= nums[i - 1])
        j--;
    swap(nums, i - 1, j);
    reverse(nums, i, nums.length - 1);
}

// src/notebook/permutation/Permutations.java
/**
 * @return all k-permutations of [0...n-1]
 */
public static List<List<Integer>> permutations(int n, int k) {
    Queue<List<Integer>> q = new LinkedList<>(Arrays.asList(new ArrayList<>()));
    Queue<List<Integer>> r = new LinkedList<>(Arrays.asList(new ArrayList<>()));
    for (int i = 0; i < n; i++)
        r.peek().add(i);
    while (q.peek().size() < k) {
        List<Integer> qq = q.poll();
        List<Integer> rr = r.poll();
        for (int i = 0; i < rr.size(); i++) {
            List<Integer> copyqq = new ArrayList<>(qq);
            List<Integer> copyrr = new ArrayList<>(rr);
            copyqq.add(copyrr.remove(i));
            q.offer(copyqq);
            r.offer(copyrr);
        }
    }
    return new ArrayList<>(q);
}

// src/notebook/prime/Factorization.java
public static List<Long> factorize(long n) {
    List<Long> factors = new ArrayList<>();
    for (long f = 2; f * f <= n; f++) { // using (f < n) is slower
        while (n % f == 0) {
            factors.add(f);
            n /= f;
        }
    }
    if (n > 1)
        factors.add(n);
    return factors;
}

// src/notebook/prime/PrimeUtil.java
public static List<Integer> primes(int n) {
    List<Integer> primes = new ArrayList<>();
    boolean[] isComposite = new boolean[n];
    for (int i = 2; i < n; i++) {
        if (!isComposite[i]) {
            primes.add(i);
            for (int j = 2; i * j < n; j++)
                isComposite[i * j] = true;
        }
    }
    return primes;
}

// src/notebook/queue/MedianQueue.java
/**
 * Data structure that keeps track of median
 */
public class MedianQueue {

    Queue<Long> maxHeap = new PriorityQueue<>(Collections.reverseOrder()), minHeap = new PriorityQueue<>();

    public void add(long n) {
        maxHeap.add(n);
        minHeap.add(maxHeap.poll());
    }

    public double median() {
        while (maxHeap.size() - minHeap.size() >= 2)
            minHeap.offer(maxHeap.poll());
        while (minHeap.size() - maxHeap.size() >= 1)
            maxHeap.offer(minHeap.poll());
        return maxHeap.size() == minHeap.size() ? (maxHeap.peek() + minHeap.peek()) / 2.0 : maxHeap.peek();
    }

    public boolean remove(long n) {
        return maxHeap.remove(n) || minHeap.remove(n);
    }

}

// src/notebook/search/SearchUtil.java
public static int binarySearchBiasL(int[] arr, int key) {
    int l = -1, h = arr.length - 1;
    while (l < h - 1) {
        int m = (l + h) >>> 1;
        if (arr[m] >= key)
            h = m;
        else
            l = m;
    }
    return h;

}

// src/notebook/search/SearchUtil.java
public static int binarySearchBiasR(int[] arr, int key) {
    int l = 0, h = arr.length;
    while (l < h - 1) {
        int m = (l + h) >>> 1;
        if (arr[m] <= key)
            l = m;
        else
            h = m;
    }
    return l;
}

// src/notebook/set/Subsets.java
public static List<List<Integer>> subsets(int... nums) {
    List<List<Integer>> subsets = new ArrayList<>();
    subsets.add(new ArrayList<>());
    for (int i = 0, size = subsets.size(); i < nums.length; i++, size = subsets.size()) {
        for (int j = 0; j < size; j++) {
            List<Integer> l = new ArrayList<>(subsets.get(j));
            l.add(nums[i]);
            subsets.add(l);
        }
    }
    return subsets;
}

// src/notebook/set/Subsets.java
/**
 * The given set may contain duplicates. <br>
 * The solution must not contain duplicates.
 */
public static List<List<Integer>> subsetsWithDup(int... nums) {
    Arrays.sort(nums);
    List<List<Integer>> subsets = new ArrayList<>();
    subsets.add(new ArrayList<>());
    for (int i = 0, presize = 0, cursize = subsets
            .size(); i < nums.length; i++, presize = cursize, cursize = subsets.size()) {
        for (int j = i == 0 || nums[i] != nums[i - 1] ? 0 : presize; j < cursize; j++) {
            List<Integer> subset = new ArrayList<>(subsets.get(j));
            subset.add(nums[i]);
            subsets.add(subset);
        }
    }
    return subsets;
}

// src/notebook/set/SubsetSum.java
/**
 * @return number of subsets whose sum is k
 */
public int subsetSum(int[] nums, int k) {
    int[] dp = new int[k + 1];
    dp[0] = 1;
    for (int n : nums)
        for (int i = k; i >= n; i--)
            dp[i] += dp[i - n];
    return dp[k];
}

// src/notebook/string/EditDistance.java
public static int minDistance(String s, String t) {
    int m = s.length();
    int n = t.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 0; i <= m; i++)
        dp[i][0] = i;
    for (int j = 0; j <= n; j++)
        dp[0][j] = j;
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++)
            if (s.charAt(i - 1) == t.charAt(j - 1))
                dp[i][j] = dp[i - 1][j - 1];
            else
                dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1]));
    return dp[m][n];
}

// src/notebook/string/FormatTest.java
@Test
public void test() {
    // rounded to 4th
    assertEquals("0.1235", String.format("%.4f", 0.12345));

    // add 0's to end
    assertEquals("0.1000", String.format("%.4f", 0.1));

    // add 0's to begin
    assertEquals("0012", String.format("%04d", 12));

    // rounded
    assertEquals("00.14", new DecimalFormat("00.00").format(0.135));

    // convenient way to print spaces
    assertEquals("[  xy]", String.format("[%4s]", "xy"));
}

// src/notebook/string/LongestCommonSubsequence.java
public static int longestCommonSubsequence(String s, String t) {
    // DP[i][j] := LCS(s.substring(i), t.substring(j))
    int dp[][] = new int[s.length() + 1][t.length() + 1];
    for (int i = s.length() - 1; i >= 0; i--)
        for (int j = t.length() - 1; j >= 0; j--)
            dp[i][j] = s.charAt(i) == t.charAt(j) ? dp[i + 1][j + 1] + 1 : Math.max(dp[i + 1][j], dp[i][j + 1]);
    return dp[0][0];
}

// src/notebook/tree/SegmentTree.java
public class SegmentTree {

    final class Node {
        final Node left, right;
        final int begin, end;
        long sum;

        Node(Node left, Node right, int begin, int end, long sum) {
            this.left = left;
            this.right = right;
            this.begin = begin;
            this.end = end;
            this.sum = sum;
        }
    }

    final Node root;

    public SegmentTree(int... arr) {
        root = buildTree(arr, 0, arr.length);
    }

    private Node buildTree(int[] arr, int b, int e) {
        if (arr.length == 0)
            return null;
        if (b + 1 == e)
            return new Node(null, null, b, e, arr[b]);
        int m = (b + e) >>> 1;
        Node l = buildTree(arr, b, m);
        Node r = buildTree(arr, m, e);
        return new Node(l, r, b, e, l.sum + r.sum);
    }

    /**
     * @param begin
     *            index inclusive
     * @param end
     *            index exclusive
     * @return sum in [begin, end)
     */
    public long sum(int begin, int end) {
        return sumRec(root, begin, end);
    }

    private long sumRec(Node root, int begin, int end) {
        if (root == null || root.end < begin || end < root.begin)
            return 0;
        if (begin <= root.begin && root.end <= end)
            return root.sum;
        return sumRec(root.left, begin, end) + sumRec(root.right, begin, end);
    }

    public void update(int i, int value) {
        updateRec(root, i, value);
    }

    private void updateRec(Node root, int i, int value) {
        if (root.begin == i && i + 1 == root.end)
            root.sum = value;
        else if (root.begin <= i && i < root.end) {
            updateRec(root.left, i, value);
            updateRec(root.right, i, value);
            root.sum = root.left.sum + root.right.sum;
        }
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        toStringAsTree(sb, root, 0);
        return sb.toString();
    }

    private void toStringAsTree(StringBuilder sb, Node root, int depth) {
        if (root == null)
            return;
        for (int i = 0; i < depth; i++)
            sb.append(' ');
        String nodeInfo = "[" + root.begin + ", " + root.end + ") sum = " + root.sum;
        sb.append(nodeInfo).append('\n');
        toStringAsTree(sb, root.left, depth + 1);
        toStringAsTree(sb, root.right, depth + 1);
    }

}

// src/notebook/tree/TwoDTree.java
/**
 * @author Yuxiang Zhang
 */
public class TwoDTree {

    private static final class Node {
        private Node left, right;
        private final Point p;

        private final boolean y;

        private Node(Point p, boolean y) {
            this.p = p;
            this.y = y;
        }
    }

    private Node root;
    private Comparator<Point> xcomp = (p, q) -> p.x - q.x;
    private Comparator<Point> ycomp = (p, q) -> p.y - q.y;

    public TwoDTree(Point[] points) {
        buildTree(points);
    }

    private void buildTree(Point[] points) {
        root = buildTree(points, 0, points.length - 1, false);
    }

    private Node buildTree(Point[] points, int l, int h, boolean y) {
        if (l > h)
            return null;
        if (l == h)
            return new Node(points[l], y);
        int mid = (l + h) >>> 1;
        Point p = ith(points, l, h, mid, y ? ycomp : xcomp);
        Node node = new Node(p, y);
        node.left = buildTree(points, l, mid - 1, !y);
        node.right = buildTree(points, mid + 1, h, !y);
        return node;
    }

    public Point nearest(Point p) {
        Point nearest[] = { node(p).p };
        if (nearest[0].equals(p))
            return nearest[0];
        nearest(nearest, p, root);
        return nearest[0];
    }

    private void nearest(Point[] nearest, Point p, Node root) {
        if (root == null)
            return;
        if (distsq(root.p, p) < distsq(nearest[0], p))
            nearest[0] = root.p;

        // distance to hyper-plane
        int dist = root.y ? p.y - root.p.y : p.x - root.p.x;
        int dsq = dist * dist;
        // radius of hyper-sphere centered at p
        int rsq = distsq(nearest[0], p);

        if ((root.y ? ycomp : xcomp).compare(p, root.p) < 0) {
            nearest(nearest, p, root.left);
            if (rsq > dsq)
                nearest(nearest, p, root.right);
        } else {
            nearest(nearest, p, root.right);
            if (rsq > dsq)
                nearest(nearest, p, root.left);
        }
    }

    private Node node(Point p) {
        Node cur = root, pre = null;
        while (cur != null) {
            if (cur.p.equals(p))
                return cur;
            pre = cur;
            cur = (cur.y ? ycomp : xcomp).compare(p, cur.p) < 0 ? cur.left : cur.right;
        }
        return pre;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        toString(sb, root, 0);
        return sb.toString();
    }

    private void toString(StringBuilder sb, Node n, int depth) {
        for (int i = 0; i < depth; i++)
            sb.append(' ');
        if (n == null) {
            sb.append(n).append('\n');
            return;
        }
        sb.append(n.p).append(' ').append(n.y ? 'y' : 'x').append('\n');
        if (n.left != null || n.right != null) {
            toString(sb, n.left, depth + 1);
            toString(sb, n.right, depth + 1);
        }
    }
}

